// FerroScript Self-Hosted Runtime
// Provides fs_String type and string operations

// External libc functions
extern fn malloc(size: i32) -> *i8;
extern fn free(ptr: *i8);
extern fn memcpy(dest: *i8, src: *i8, n: i32) -> *i8;
extern fn putchar(c: i8) -> i32;
extern fn realloc(ptr: *i8, size: i32) -> *i8;

// String struct - matches LLVM layout { i8*, i32, i32 }
// Refcount is stored at ptr[-4] (4 bytes prepended to the heap allocation)
export struct fs_String {
    ptr: *i8,
    len: i32,
    cap: i32
}

// Allocate a new string with given capacity
// Allocates 4 extra bytes at the start for the refcount (rc stored at ptr[-4])
export fn fs_string_alloc(size: i32) -> fs_String {
    let mut result: fs_String = fs_String { ptr: null, len: 0, cap: size };
    unsafe {
        let raw: *i8 = malloc(size + 5);
        if (raw != null) {
            // Store initial refcount of 1 at the start of the allocation
            let rc_ptr: *i32 = raw as *i32;
            *rc_ptr = 1;
            // ptr points past the 4-byte rc header
            result.ptr = raw + 4;
            *(result.ptr) = 0;
        };
    }
    return result;
}

// Create a string from a literal (allocates and copies)
export fn fs_string_from_literal(data: *i8, len: i32) -> fs_String {
    let mut s: fs_String = fs_string_alloc(len);
    unsafe {
        if (s.ptr != null) {
            memcpy(s.ptr, data, len);
            *(s.ptr + len) = 0;
            s.len = len;
        };
    }
    return s;
}

// Concatenate two strings (takes pointers to avoid ABI issues)
export fn fs_string_concat(s1: *fs_String, s2: *fs_String) -> fs_String {
    let new_len: i32 = (*s1).len + (*s2).len;
    let mut s: fs_String = fs_string_alloc(new_len);
    unsafe {
        if (s.ptr != null) {
            if ((*s1).ptr != null) {
                memcpy(s.ptr, (*s1).ptr, (*s1).len);
            };
            if ((*s2).ptr != null) {
                memcpy(s.ptr + (*s1).len, (*s2).ptr, (*s2).len);
            };
            *(s.ptr + new_len) = 0;
            s.len = new_len;
        };
    }
    return s;
}

// Print a string (takes pointer)
export fn fs_print_string(s: *fs_String) {
    unsafe {
        if ((*s).ptr != null) {
            let mut i: i32 = 0;
            while (i < (*s).len) {
                let mut c: i8 = *((*s).ptr + i);
                putchar(c);
                i = i + 1;
            }
            putchar(10); // newline
        } else {
            // Print "(null)" for null string pointers (parity with C runtime)
            putchar(40);  // (
            putchar(110); // n
            putchar(117); // u
            putchar(108); // l
            putchar(108); // l
            putchar(41);  // )
            putchar(10);  // newline
        };
    }
}

// Print digits from a buffer in reverse order (helper)
fn fs_print_digits(buf: *i8, len: i32) {
    // Print buffer[len-1] down to buffer[0]
    // Use a forward index: print buf[len - 1 - i] for i = 0..len-1
    unsafe {
        let mut i: i32 = 0;
        while (i < len) {
            putchar(*(buf + len - 1 - i));
            i = i + 1;
        }
    }
}

// Print the digits of a positive integer, then newline
fn fs_print_positive(val_in: i32) {
    unsafe {
        let mut buf: *i8 = malloc(12);
        let mut len: i32 = 0;
        let mut val: i32 = val_in;
        while (val > 0) {
            let mut digit: i32 = val - (val / 10) * 10;
            *(buf + len) = digit + 48;
            len = len + 1;
            val = val / 10;
        }
        fs_print_digits(buf, len);
        free(buf);
    }
}

// Print an integer (no printf dependency)
export fn fs_print_int(n: i32) {
    unsafe {
        if (n == 0) {
            putchar(48); // '0'
        } else {
            if (n < 0) {
                putchar(45); // '-'
                fs_print_positive(0 - n);
            } else {
                fs_print_positive(n);
            };
        };
        putchar(10); // newline
    }
}

// ---- String Utilities ----

// Compare two strings for equality (byte-by-byte)
export fn fs_string_eq(s1: *fs_String, s2: *fs_String) -> bool {
    let mut result: bool = true;
    if ((*s1).len != (*s2).len) {
        result = false;
    } else {
        unsafe {
            let mut i: i32 = 0;
            while (i < (*s1).len) {
                if (*((*s1).ptr + i) != *((*s2).ptr + i)) {
                    result = false;
                };
                i = i + 1;
            }
        }
    };
    return result;
}

// Lexicographic comparison of two strings.
// Returns -1 if s1 < s2, 0 if equal, 1 if s1 > s2.
export fn fs_string_cmp(s1: *fs_String, s2: *fs_String) -> i32 {
    let mut result: i32 = 0;
    let mut done: bool = false;
    unsafe {
        let mut i: i32 = 0;
        let mut min_len: i32 = (*s1).len;
        if ((*s2).len < min_len) {
            min_len = (*s2).len;
        };
        while (i < min_len) {
            if (done == false) {
                let a: i8 = *((*s1).ptr + i);
                let b: i8 = *((*s2).ptr + i);
                if (a < b) {
                    result = 0 - 1;
                    done = true;
                } else {
                    if (a > b) {
                        result = 1;
                        done = true;
                    };
                };
            };
            i = i + 1;
        }
    };
    if (done == false) {
        if ((*s1).len < (*s2).len) {
            result = 0 - 1;
        } else {
            if ((*s1).len > (*s2).len) {
                result = 1;
            };
        };
    };
    return result;
}

// Return the length of a string
export fn fs_string_len(s: *fs_String) -> i32 {
    return (*s).len;
}

// Return the byte at index idx (0-based). Returns 0 for out-of-bounds.
export fn fs_string_index(s: *fs_String, idx: i32) -> i8 {
    let mut result: i8 = 0 as i8;
    if (idx < 0) {
        result = 0 as i8;
    } else {
        if (idx < (*s).len) {
            unsafe {
                result = *((*s).ptr + idx);
            };
        };
    };
    return result;
}

// Return a new string from start (inclusive) to end (exclusive).
// Clamps to valid range silently.
export fn fs_string_slice(s: *fs_String, start_in: i32, end_in: i32) -> fs_String {
    let mut start: i32 = start_in;
    let mut end: i32 = end_in;
    if (start < 0) {
        start = 0;
    };
    if (end > (*s).len) {
        end = (*s).len;
    };
    if (start > end) {
        start = end;
    };
    let new_len: i32 = end - start;
    let mut result: fs_String = fs_string_alloc(new_len);
    unsafe {
        if (result.ptr != null) {
            if (new_len > 0) {
                memcpy(result.ptr, (*s).ptr + start, new_len);
            };
            *(result.ptr + new_len) = 0 as i8;
            result.len = new_len;
        };
    }
    return result;
}

// Free the backing memory of a string. Frees from ptr-4 (the rc header).
export fn fs_string_free(s: *fs_String) {
    unsafe {
        if ((*s).ptr != null) {
            // The actual malloc'd block starts 4 bytes before ptr
            let raw: *i8 = (*s).ptr - 4;
            free(raw);
            (*s).ptr = null;
            (*s).len = 0;
            (*s).cap = 0;
        };
    }
}

// ---- Reference Counting ----
// Refcount is stored at ptr[-4] as an i32, shared across all copies of the struct.

// Increment the reference count of a string
export fn fs_rc_retain(s: *fs_String) {
    unsafe {
        if ((*s).ptr != null) {
            let rc_ptr: *i32 = ((*s).ptr - 4) as *i32;
            *rc_ptr = *rc_ptr + 1;
        };
    }
}

// Decrement the reference count; free when it reaches zero
export fn fs_rc_release(s: *fs_String) {
    unsafe {
        if ((*s).ptr != null) {
            let rc_ptr: *i32 = ((*s).ptr - 4) as *i32;
            *rc_ptr = *rc_ptr - 1;
            if (*rc_ptr <= 0) {
                fs_string_free(s);
            };
        };
    }
}

// ---- Vec (Dynamic Array) ----
// Type-erased vector: stores raw bytes, elem_size tracks element size.
// The compiler maps Vec<T> → fs_Vec and injects elem_size + bitcasts.

export struct fs_Vec {
    data: *i8,
    len: i32,
    cap: i32,
    elem_size: i32
}

// Create a new empty vec with given element size
export fn fs_vec_new(elem_size: i32) -> fs_Vec {
    let mut v: fs_Vec = fs_Vec { data: null, len: 0, cap: 0, elem_size: elem_size };
    return v;
}

// Push a value (given as a raw byte pointer) into the vec
export fn fs_vec_push(v: *fs_Vec, item: *i8) {
    unsafe {
        if ((*v).len == (*v).cap) {
            // Grow: double capacity (min 4)
            let mut new_cap: i32 = (*v).cap * 2;
            if (new_cap < 4) {
                new_cap = 4;
            };
            let new_data: *i8 = realloc((*v).data, new_cap * (*v).elem_size);
            (*v).data = new_data;
            (*v).cap = new_cap;
        };
        // Copy elem_size bytes from item into data[len * elem_size]
        let offset: i32 = (*v).len * (*v).elem_size;
        memcpy((*v).data + offset, item, (*v).elem_size);
        (*v).len = (*v).len + 1;
    }
}

// Get a pointer to the element at index
export fn fs_vec_get(v: *fs_Vec, index: i32) -> *i8 {
    unsafe {
        let offset: i32 = index * (*v).elem_size;
        return (*v).data + offset;
    }
}

// Set the element at index from a raw byte pointer
export fn fs_vec_set(v: *fs_Vec, index: i32, item: *i8) {
    unsafe {
        let offset: i32 = index * (*v).elem_size;
        memcpy((*v).data + offset, item, (*v).elem_size);
    }
}

// Pop the last element and return a pointer to it
export fn fs_vec_pop(v: *fs_Vec) -> *i8 {
    unsafe {
        (*v).len = (*v).len - 1;
        let offset: i32 = (*v).len * (*v).elem_size;
        return (*v).data + offset;
    }
}

// Return the length
export fn fs_vec_len(v: *fs_Vec) -> i32 {
    return (*v).len;
}

// Free the backing buffer
export fn fs_vec_free(v: *fs_Vec) {
    unsafe {
        if ((*v).data != null) {
            free((*v).data);
            (*v).data = null;
            (*v).len = 0;
            (*v).cap = 0;
        };
    }
}

// ---- HashMap ----
// Type-erased hash map with open addressing (linear probing).
// Each entry stores: hash (i32), occupied flag (i32), then key bytes, then value bytes.

export struct fs_HashMap {
    data: *i8,
    count: i32,
    capacity: i32,
    key_size: i32,
    value_size: i32,
    entry_size: i32
}

// Hash functions
export fn fs_hash_int(val: i32) -> i32 {
    // Knuth multiplicative hash
    let mut h: i32 = val * 2654435;
    if (h < 0) {
        h = 0 - h;
    };
    return h;
}

export fn fs_hash_string(s: *fs_String) -> i32 {
    // DJB2 hash
    let mut hash: i32 = 5381;
    let mut i: i32 = 0;
    while (i < (*s).len) {
        unsafe {
            let c: i32 = *((*s).ptr + i) as i32;
            hash = hash * 33 + c;
        };
        i = i + 1;
    }
    if (hash < 0) {
        hash = 0 - hash;
    };
    return hash;
}

// Entry layout: [hash: i32, occupied: i32, key: key_size bytes, value: value_size bytes]
// Total entry_size = 8 + key_size + value_size

fn fs_hashmap_entry_ptr(m: *fs_HashMap, index: i32) -> *i8 {
    unsafe {
        return (*m).data + index * (*m).entry_size;
    }
}

fn fs_hashmap_entry_hash(entry: *i8) -> i32 {
    unsafe {
        return *(entry as *i32);
    }
}

fn fs_hashmap_entry_occupied(entry: *i8) -> i32 {
    unsafe {
        return *((entry + 4) as *i32);
    }
}

fn fs_hashmap_set_hash(entry: *i8, h: i32) {
    unsafe {
        *(entry as *i32) = h;
    }
}

fn fs_hashmap_set_occupied(entry: *i8, val: i32) {
    unsafe {
        *((entry + 4) as *i32) = val;
    }
}

fn fs_hashmap_entry_key(entry: *i8) -> *i8 {
    return entry + 8;
}

fn fs_hashmap_entry_value(entry: *i8, key_size: i32) -> *i8 {
    return entry + 8 + key_size;
}

// Create a new empty hash map
export fn fs_hashmap_new(key_size: i32, value_size: i32) -> fs_HashMap {
    let entry_size: i32 = 8 + key_size + value_size;
    let initial_cap: i32 = 16;
    let mut m: fs_HashMap = fs_HashMap {
        data: null, count: 0, capacity: initial_cap,
        key_size: key_size, value_size: value_size, entry_size: entry_size
    };
    unsafe {
        let total: i32 = initial_cap * entry_size;
        let raw: *i8 = malloc(total);
        // Zero-initialize all entries (occupied = 0)
        let mut i: i32 = 0;
        while (i < total) {
            *(raw + i) = 0 as i8;
            i = i + 1;
        }
        m.data = raw;
    }
    return m;
}

// Compare key_size bytes for equality
fn fs_mem_eq(a: *i8, b: *i8, size: i32) -> bool {
    let mut result: bool = true;
    let mut i: i32 = 0;
    unsafe {
        while (i < size) {
            if (*(a + i) != *(b + i)) {
                result = false;
            };
            i = i + 1;
        }
    }
    return result;
}

// Resize the hash map when load factor exceeds 75%
fn fs_hashmap_resize(m: *fs_HashMap) {
    let old_cap: i32 = (*m).capacity;
    let old_data: *i8 = (*m).data;
    let new_cap: i32 = old_cap * 2;
    let total: i32 = new_cap * (*m).entry_size;
    unsafe {
        let new_data: *i8 = malloc(total);
        let mut i: i32 = 0;
        while (i < total) {
            *(new_data + i) = 0 as i8;
            i = i + 1;
        }
        (*m).data = new_data;
        (*m).capacity = new_cap;
        (*m).count = 0;

        // Reinsert all occupied entries
        let mut j: i32 = 0;
        while (j < old_cap) {
            let entry: *i8 = old_data + j * (*m).entry_size;
            if (fs_hashmap_entry_occupied(entry) == 1) {
                let h: i32 = fs_hashmap_entry_hash(entry);
                let key_ptr: *i8 = fs_hashmap_entry_key(entry);
                let val_ptr: *i8 = fs_hashmap_entry_value(entry, (*m).key_size);
                // Find slot in new table
                let mut idx: i32 = h - (h / new_cap) * new_cap;
                let mut placed: bool = false;
                while (placed == false) {
                    let new_entry: *i8 = (*m).data + idx * (*m).entry_size;
                    if (fs_hashmap_entry_occupied(new_entry) == 0) {
                        fs_hashmap_set_hash(new_entry, h);
                        fs_hashmap_set_occupied(new_entry, 1);
                        memcpy(fs_hashmap_entry_key(new_entry), key_ptr, (*m).key_size);
                        memcpy(fs_hashmap_entry_value(new_entry, (*m).key_size), val_ptr, (*m).value_size);
                        (*m).count = (*m).count + 1;
                        placed = true;
                    } else {
                        idx = idx + 1;
                        if (idx == new_cap) {
                            idx = 0;
                        };
                    };
                }
            };
            j = j + 1;
        }
        free(old_data);
    }
}

// Insert a key-value pair (given as raw byte pointers)
export fn fs_hashmap_insert(m: *fs_HashMap, hash: i32, key: *i8, value: *i8) {
    // Resize if load factor > 75%
    if ((*m).count * 4 > (*m).capacity * 3) {
        fs_hashmap_resize(m);
    };
    let mut idx: i32 = hash - (hash / (*m).capacity) * (*m).capacity;
    unsafe {
        let mut done: bool = false;
        while (done == false) {
            let entry: *i8 = fs_hashmap_entry_ptr(m, idx);
            let occ: i32 = fs_hashmap_entry_occupied(entry);
            if (occ == 0) {
                // Empty slot: insert here
                fs_hashmap_set_hash(entry, hash);
                fs_hashmap_set_occupied(entry, 1);
                memcpy(fs_hashmap_entry_key(entry), key, (*m).key_size);
                memcpy(fs_hashmap_entry_value(entry, (*m).key_size), value, (*m).value_size);
                (*m).count = (*m).count + 1;
                done = true;
            } else {
                if (occ == 1) {
                    // Check if same key — update value
                    if (fs_mem_eq(fs_hashmap_entry_key(entry), key, (*m).key_size)) {
                        memcpy(fs_hashmap_entry_value(entry, (*m).key_size), value, (*m).value_size);
                        done = true;
                    };
                };
                if (done == false) {
                    idx = idx + 1;
                    if (idx == (*m).capacity) {
                        idx = 0;
                    };
                };
            };
        }
    }
}

// Get a pointer to the value for a given key, returns null if not found
export fn fs_hashmap_get(m: *fs_HashMap, hash: i32, key: *i8) -> *i8 {
    let mut idx: i32 = hash - (hash / (*m).capacity) * (*m).capacity;
    unsafe {
        let mut i: i32 = 0;
        while (i < (*m).capacity) {
            let entry: *i8 = fs_hashmap_entry_ptr(m, idx);
            let occ: i32 = fs_hashmap_entry_occupied(entry);
            if (occ == 0) {
                return null;
            };
            if (occ == 1) {
                if (fs_mem_eq(fs_hashmap_entry_key(entry), key, (*m).key_size)) {
                    return fs_hashmap_entry_value(entry, (*m).key_size);
                };
            };
            idx = idx + 1;
            if (idx == (*m).capacity) {
                idx = 0;
            };
            i = i + 1;
        }
    }
    return null;
}

// Check if key exists
export fn fs_hashmap_contains(m: *fs_HashMap, hash: i32, key: *i8) -> bool {
    let result: *i8 = fs_hashmap_get(m, hash, key);
    if (result == null) {
        return false;
    };
    return true;
}

// Remove a key
export fn fs_hashmap_remove(m: *fs_HashMap, hash: i32, key: *i8) {
    let mut idx: i32 = hash - (hash / (*m).capacity) * (*m).capacity;
    let mut done: bool = false;
    unsafe {
        let mut i: i32 = 0;
        while (i < (*m).capacity) {
            if (done == false) {
                let entry: *i8 = fs_hashmap_entry_ptr(m, idx);
                let occ: i32 = fs_hashmap_entry_occupied(entry);
                if (occ == 0) {
                    done = true;
                };
                if (done == false) {
                    if (occ == 1) {
                        if (fs_mem_eq(fs_hashmap_entry_key(entry), key, (*m).key_size)) {
                            fs_hashmap_set_occupied(entry, 2);
                            (*m).count = (*m).count - 1;
                            done = true;
                        };
                    };
                };
                if (done == false) {
                    idx = idx + 1;
                    if (idx == (*m).capacity) {
                        idx = 0;
                    };
                };
            };
            i = i + 1;
        }
    }
}

// Return the number of entries
export fn fs_hashmap_len(m: *fs_HashMap) -> i32 {
    return (*m).count;
}

// Free the backing buffer
export fn fs_hashmap_free(m: *fs_HashMap) {
    unsafe {
        if ((*m).data != null) {
            free((*m).data);
            (*m).data = null;
            (*m).count = 0;
            (*m).capacity = 0;
        };
    }
}
